#!/usr/bin/env python
import argparse
import os
from os import listdir
from os.path import isfile, join
import socket
from argparse import RawTextHelpFormatter
import subprocess
from sys import platform
import SimpleHTTPServer
import SocketServer
from pip import locations
import webbrowser
if platform == "darwin": platform = "osx" #for clarity
import time
import sys

class Const:
    data_directory = "data"
    throughput = "[Throughput] "
    latency = "[Latency] "

#Create argparser with help page info.
parser = argparse.ArgumentParser(description="Collect and analyze WiFi LAN network speeds.",
                                 epilog="Project home page:\n  http://marklalor.com/projects/wifistat\nGitHub:\n  http://github.com/MarkLalor/WifiStat",
                                 formatter_class=RawTextHelpFormatter)

#Get info about the method to actually be used for the test.
parser.add_argument('--iperf', help='iperf server IP to run the test.')
parser.add_argument('--iperfport', default=5001, type=int, help='Specify an alternative iperf server port.')
parser.add_argument('--speedtest', nargs='?', default=-1, help='Specify a speedtest-cli server id to run the test (see speedtest-cli --list, defaults to first one).')
parser.add_argument('--ping', nargs='?', default=-1, help='IP to be pinged in order to test latency.')

#Get info on how to log the data (WiFi network name and location may wish to be recorded)
parser.add_argument('-n', '--network', help='Manually specify the name of this network (default on OS X is the connected WiFi SSID, "network" otherwise).')
parser.add_argument('-l', '--location', default='nolocation', help='Name of location to log speed for (e.g. "basement"), defaults to "nolocation".')

#Other ease of use options
parser.add_argument('-t', '--trials', default=5, type=int, help='Number of trials to run for this location.')
parser.add_argument('-d', '--delay', default=0, type=int, help='Delay between trials.')
parser.add_argument('-p', '--prompt', action='store_true', help='Prompt for [ENTER] keypress between trials.')
parser.add_argument('-v', '--verbose', action='store_true', help='Increase output verbosity')

#sdfadf
parser.add_argument('--process', action='store_true', help='Process collected data for analysis.')
parser.add_argument('--server', nargs='?', default=-1, type=int, help='Start and open the web interface.')


#Only prints if the --verbose flag is specified. 
def print_verbose(string):
    if args.verbose:
        print string

#Simple wrapper around subprocess to run commands...
def cmd(subprocess_args, short=True, use_shell=False):
    if short:
        return subprocess.Popen(subprocess_args, stdout=subprocess.PIPE, shell=use_shell).communicate()[0].rstrip()
    else:
        return subprocess.Popen(subprocess_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=use_shell).communicate()
    
#Python 2 & 3 compatible "press enter to continue" 
def wait(prefix):
    if sys.version_info[0] == 2:
        raw_input(prefix + "Press enter to continue...")
    else:
        input(prefix + "Press enter to continue...")

#Automatically determine the WiFi network name.
def get_best_network_name():
    if platform == "osx":
        return cmd(["/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk '/ SSID/ {print substr($0, index($0, $2))}'"], use_shell=True)
    else:
        return "network"

#IP validator
def is_valid_ip(ip):
    try: socket.inet_aton(ip); return True
    except socket.error: return False

#Attempts to get LAN router IP to ping, returns Google's DNS server (8.8.8.8) otherwise.
def get_best_ping_ip():
    if platform == "osx":
        return cmd(["netstat -rn | grep default | awk '{print $2}'"], use_shell=True)
    else:
        return "8.8.8.8"

#Determines the best speedtest server from the "speedtest-cli --list" command.
def getspeedtest_server():
    return cmd(["speedtest-cli --list | sed -n 3p | awk 'BEGIN { OFS = \")\"} {print $1}' | sed s'/)//g'"], use_shell=True)

args = parser.parse_args()

# Example value of "self" in "do_GET(self):"
# requestline: GET /?data=sdf HTTP/1.1
# wfile: <socket._fileobject object at 0x101e49650>
# request: <socket._socketobject object at 0x1037917c0>
# raw_requestline: GET /?data=sdf HTTP/1.1
# 
# server: <SocketServer.TCPServer instance at 0x10493e518>
# headers: Host: localhost:8000
# Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
# Cookie: G_ENABLED_IDPS=google; _ga=GA1.1.1738252731.1446445775; wp-settings-1=mfold%3Do%26hidetb%3D1%26libraryContent%3Dbrowse%26align%3Dnone%26imgsize%3Dlarge%26editor%3Dtinymce%26advImgDetails%3Dshow%26wplink%3D1%26urlbutton%3Dcustom; wp-settings-time-1=1446446165
# User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9
# Accept-Language: en-us
# Accept-Encoding: gzip, deflate
# Connection: keep-alive
# 
# connection: <socket._socketobject object at 0x1037917c0>
# command: GET
# rfile: <socket._fileobject object at 0x101e496d0>
# path: /?data=sdf
# request_version: HTTP/1.1
# client_address: ('127.0.0.1', 64895)
# close_connection: 1
class WiFiStatRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    def do_GET(self): 
        print_verbose('\n'.join("%s: %s" % item for item in vars(self).items()))
        if self.path == '/':
            self.path = 'web/main.html'
        return SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
    
class WiFiStatTCPServer(SocketServer.TCPServer):
    def server_bind(self):
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)

if args.server != -1:
#     webbrowser.open("file://" + os.path.realpath("data.html"))
    if args.server is None:
        args.server = 8000
    
    port = args.server
    
    httpd = WiFiStatTCPServer(("", port), WiFiStatRequestHandler)
    
    print "Serving at http://localhost:" + str(port)
    webbrowser.open("http://localhost:" + str(port))
    httpd.serve_forever()

#Get a network name from SSID or whatever. 
if args.network is None:
    print_verbose("Automatically detecting a network name from SSID...")
    args.network = get_best_network_name()
if not args.process:
    print "Network name: " + str(args.network)

#Get an IP to ping test for latency.
if args.ping is None:
    print_verbose("Automatically detecting a latency test IP...")
    args.ping = get_best_ping_ip()
elif args.ping == -1:
    print_verbose("Not testing latency/ping.")
if not args.ping is None and args.ping != -1:
    print "Latency ping test IP: " + str(args.ping) 

#Check that iperf ip is valid
if args.iperf:
    if not is_valid_ip(args.iperf):
        sys.exit("Invalid iperf IP given: " + args.iperf)
#Check that the ping ip is valid
if args.ping != -1:
    if not is_valid_ip(args.ping):
        sys.exit("Invalid ping IP given: " + args.ping)
        
#Handle the eight possible combinations.
#At least one of speedtest, iperf, or ping must be selected.
#args.speedtest == -1 indicates that the --speedtest flag was supplied but no args were given whereas
#args.speedtest, args.iperf, or args.ping == None indicates that the flag was not suppied at all
method = "nothroughput"
if args.iperf is None and not args.speedtest == -1:
    method="speedtest"
    if args.speedtest is None:
        print_verbose("Automatically choosing a speedtest server.")
        args.speedtest = getspeedtest_server();
    print "Throughput speedtest server ID: " + args.speedtest
elif not args.iperf is None and args.speedtest == -1:
    method="iperf"
    print "Throughput iperf server IP: " + args.iperf
elif not args.iperf is None and not args.speedtest == -1:
    sys.exit("Cannot use both speedtest-cli and iperf to test. Only specify one.")
else:
    print_verbose("Not testing throughput/speed.")
    
if not args.process: print ""

#Print all the args if in verbose mode.
print_verbose("Running WiFiStat with the following parameters:")
for key, value in vars(args).iteritems(): print_verbose("  " + key + ": " + str(value))

##### TEST FUNCTIONS #####

### IPERF ###
def iperf_run(ip):
    print Const.throughput + "Testing with iperf server at " + ip
    result = cmd(["iperf", "-c", ip, "-f", "m", "-p", str(args.iperfport)], short=False)
    if "failed" in result[0]:
        sys.exit("Failed to connect to iperf server at " + args.iperf)
    else:
        return result[0].splitlines()[6].split()[6]

### SPEEDTEST CLI ####
def speedtest_run(server):
    pass 

### PING ###
def ping_run(ip):
    print Const.latency + "Pinging server at " + ip
    return float(cmd(["ping", "-c", "1", ip]).splitlines()[1].split()[6][5:])

### LOG TESTS ###
def log(datatype, location, value):
    filename = Const.data_directory + "/" + args.network + "/" + location + "." + datatype
    if not os.path.exists(Const.data_directory + "/" + args.network):
        os.makedirs(Const.data_directory + "/" + args.network)
    with open(filename, "a+") as datafile:
        datafile.write(str(value) + "\n")

##### THROUGHPUT TEST #####
for i in range(args.trials):
    if method == "speedtest":
        pass
    elif method == "iperf":
        print Const.throughput + "iperf test " + str(i+1) + "/" + str(args.trials)
        throughput = float(iperf_run(args.iperf))
        log("throughput", args.location, throughput)
        print Const.throughput + str(throughput) + " megabits/second."
        if not args.delay == 0:
            print Const.throughput + str(args.delay) + "-second delay."
        if args.prompt:
            wait(Const.throughput)
             
##### LATENCY TEST #####  
if args.ping != -1:
    for i in range(args.trials):    
        print Const.latency + "ping test " + str(i+1) + "/" + str(args.trials)
        ping = ping_run(args.ping)
        log("latency", args.location, ping)
        print Const.latency + str(ping) + " milliseconds."
        if not args.delay == 0:
            print Const.latency + str(args.delay) + "-second delay."
            time.sleep(args.delay)
        if args.prompt:
            wait(Const.latency)


def median(values):
    if len(values) % 2 == 0:
        return (values[(len(values)/2)-1] + values[len(values)/2])/2
    else:
        return values[len(values)//2]

def five_number_summary(values):
    fns_min = values[0]
    fns_q1 = median(values[:(len(values)//2)])
    fns_median = median(values)
    fns_q3 = median(values[(len(values)//2+(0 if len(values) % 2 == 0 else 1)):]) 
    fns_max = values[-1]
    return {"min": fns_min, "q1": fns_q1, "median": fns_median, "q3": fns_q3, "max": fns_max}

##### PROCESS TEST DATA #####
if args.process:
    print "Processing collected data."
    if not os.path.exists(Const.data_directory):
        sys.exit("No data to process. Use --iperf, --speedtest, or --ping to collect data about network throughput and latency.")
    networks = [x[0] for x in os.walk(Const.data_directory)][1:]
    for network in networks:
        print "Processing data from " + network
        filenames = [f.split(".")[0] for f in listdir(network) if isfile(join(network, f))]
        locations = []
        [locations.append(item) for item in filenames if item not in locations]
        for location in locations:
            print '  Processing data for location "' + location + '"'
            with open(network + "/" + location + ".throughput") as f:
                throughputs = sorted([float(i) for i in f.read().splitlines()])
            print_verbose("  Throughputs: " + str(throughputs))
            with open(network + "/" + location + ".latency") as f:
                latencies = sorted([float(i) for i in f.read().splitlines()])
            print_verbose("  Latencies: " + str(latencies))
            
            fns_throughput = five_number_summary(throughputs)
            fns_latency = five_number_summary(latencies)
            
            print "  " + str(fns_throughput)
            print "  " + str(fns_latency)